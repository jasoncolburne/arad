#!/usr/bin/env bash

set -eo pipefail

BACKENDS=(administrator reviewer reader identity)
IMAGES=(front-end-react api identity administrator reviewer reader)
ACTIVATE_SCRIPT=". \$(./echo_activate_path)"

stack_up() {
  docker compose up --remove-orphans
}

stack_daemonize() {
  docker compose up -d --remove-orphans
}

stack_down() {
  docker compose down
}

nomad_server() {
  local ENVIRONMENT=$1

  nomad agent -dev -bind=0.0.0.0 -log-level INFO -config="nomad/client.${ENVIRONMENT}.hcl"
}

# render the batch jobs to .nomad files
nomad_batch() {
  local ENVIRONMENT=$1

  rm -f nomad/batch_jobs/*.nomad

  nomad-pack render -o nomad -f "nomad/configurations/${ENVIRONMENT}.hcl" nomad/batch_jobs
  hclfmt -w nomad/batch_jobs/*.nomad
}

# render the arad pack to the screen
nomad_render() {
  local ENVIRONMENT=$1

  nomad-pack render -f "nomad/configurations/${ENVIRONMENT}.hcl" nomad/arad | hclfmt
}

nomad_plan() {
  local ENVIRONMENT=$1

  nomad-pack plan -f "nomad/configurations/${ENVIRONMENT}.hcl" nomad/arad
}

nomad_apply() {
  local ENVIRONMENT=$1

  nomad-pack run -f "nomad/configurations/${ENVIRONMENT}.hcl" nomad/arad
}

nomad_destroy() {
  local ENVIRONMENT=$1

  nomad-pack destroy -f "nomad/configurations/${ENVIRONMENT}.hcl" nomad/arad
}

nomad_migrate() {
  nomad run nomad/batch_jobs/migrate_user_database.nomad
  nomad run nomad/batch_jobs/migrate_application_database.nomad

  sleep 3

  nomad system gc
}

stack_build() {
  echo
  echo "bringing down running instances..."
  echo
  docker compose down

  echo
  echo "syncing code..."
  echo
  scripts/sync

  echo
  echo "building from compose..."
  echo
  docker compose build
  
  for IMAGE in "${IMAGES[@]}"; do
    docker tag arad_${IMAGE}:latest arad_${IMAGE}:local
  done

  echo
  echo "building redis image..."
  echo
  docker build -f redis/Dockerfile -t arad_redis redis
  docker tag arad_redis:latest arad_redis:local

  echo
  echo "building snowflake core testing image..."
  echo
  docker build --build-arg DEPLOYMENT_ENVIRONMENT=development -f core/Dockerfile -t arad_core-test core

  echo
  echo "building nginx front-end"
  echo
  docker compose -f docker-compose.build.yml up -d front-end-base
  docker compose -f docker-compose.build.yml cp front-end-base:/app/build front-end-nginx
  docker compose -f docker-compose.build.yml down
  docker build -t arad_front-end-nginx:latest front-end-nginx
  docker tag arad_front-end-nginx:latest arad_front-end-nginx:local

  echo
  echo "copying node_modules to host (this takes a bit)..."
  echo
  # this is required since we mount the volume in the same directory, meaning that the node_modules
  # directory on the container would be erased when it launched if we didn't do this
  rm -rf front-end/node_modules
  CONTAINER_ID=$(docker run --rm -d arad_front-end-react sleep 600)
  docker cp $CONTAINER_ID:/app/node_modules front-end
  docker kill $CONTAINER_ID
}

poetry_relock() {
  for BACKEND in "${BACKENDS[@]}"; do
    docker compose run --rm $BACKEND bash -c "rm -f poetry.lock && poetry lock -vv"
  done
}

be_exec() {
  local ARGUMENTS=$1

  for BACKEND in "${BACKENDS[@]}"; do
    docker compose run --rm $BACKEND bash -c "${ARGUMENTS}"
  done
}

types() {
  docker compose run --rm front-end-react ./build_types
}

nuke() {
  ./scripts/local down
  ./scripts/sync
  ./scripts/local build
  ./scripts/database drop || true
  ./scripts/database create
  ./scripts/database migrate

  echo
  echo "Arad database wiped. Set or use the configured DEFAULT_ADMIN_EMAIL to create an admin account."
  echo "In production, DEFAULT_ADMIN_EMAIL should be unset after it is used."
}

docker_image_prune() {
  # prune dangling images
  docker image prune -f
}

docker_compose_rm() {
  # remove one off containers
  docker compose rm
}

shell() {
  local SERVICE=$1

  docker compose run --rm -it "${SERVICE}" bash
}

repl() {
  local SERVICE=$1

  set +e
  read -r -d '' SHELL_SCRIPT << EOS
${ACTIVATE_SCRIPT}
PYTHONSTARTUP=${SERVICE}/repl.py ipython
EOS
  set -e

  docker compose run --rm -it "${SERVICE}" bash -c "${SHELL_SCRIPT}"
}

# we can probably do the rest in a single line by eval or something
execute() {
  local COMMAND=$1
  local ARGUMENTS=$(echo $2 | sed "s/^ *//" | sed "s/ *\$//")

  if [[ "${COMMAND}" == "up" ]]; then
    stack_up
  elif [[ "${COMMAND}" == "daemonize" ]]; then
    stack_daemonize
  elif [[ "${COMMAND}" == "down" ]]; then
    stack_down
  elif [[ "${COMMAND}" == "nomad-server" ]]; then
    nomad_server "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "nomad-batch" ]]; then
    nomad_batch "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "nomad-render" ]]; then
    nomad_render "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "nomad-plan" ]]; then
    nomad_plan "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "nomad-apply" ]]; then
    nomad_apply "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "nomad-destroy" ]]; then
    nomad_destroy "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "nomad-migrate" ]]; then
    nomad_migrate
  elif [[ "${COMMAND}" == "build" ]]; then
    stack_build
  elif [[ "${COMMAND}" == "relock" ]]; then
    poetry_relock
  elif [[ "${COMMAND}" == "exec" ]]; then
    be_exec "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "prune" ]]; then
    docker_image_prune
  elif [[ "${COMMAND}" == "rm" ]]; then
    docker_compose_rm
  elif [[ "${COMMAND}" == "types" ]]; then
    types
  elif [[ "${COMMAND}" == "nuke" ]]; then
    nuke
  elif [[ "${COMMAND}" == "shell" ]]; then
    shell "${ARGUMENTS}"
  elif [[ "${COMMAND}" == "repl" ]]; then
    repl "${ARGUMENTS}"
  else
    echo "unknown command ${COMMAND}"
    exit 1
  fi
}

execute "$1" "$2 $3 $4 $5 $6 $7 $8 $9"
